# Чем отличаются методы `equals()` и `hashCode()` в Java?

Методы `equals()` и `hashCode()` в Java имеют разные цели и играют важные роли в управлении объектами внутри коллекций, таких как `HashMap`, `HashSet` и других структурах данных, основанных на хэшировании.

### `equals()`

Метод `equals()` сравнивает два объекта на логическое равенство. По умолчанию, реализация этого метода в классе `Object` проверяет, совпадают ли ссылки (то есть, если они указывают на один и тот же объект в памяти). 

Однако многие классы переопределяют этот метод для более сложного сравнения. Например, класс `String` переопределяет метод `equals()` для сравнения содержимого строк, а не их ссылок.

Пример переопределения метода `equals()`:
```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    MyClass myClass = (MyClass) obj;
    return this.someField.equals(myClass.someField);
}
```

### `hashCode()`

Метод `hashCode()` возвращает целое число (хэш-код), которое служит для быстрого поиска объектов в коллекциях типа `HashMap`, `HashSet` и других структурах данных, использующих хэширование.

Контракт метода `hashCode()` (согласно спецификации Java) гласит, что:
1. Если два объекта равны по `equals()`, то их хэш-коды должны быть одинаковы.
2. Если хэш-коды двух объектов не равны, эти объекты не должны быть равны по `equals()`.
3. Если объект изменяется так, что изменяются его хэш-коды, то это может нарушить работу коллекций, использующих хэш-коды.

Пример переопределения метода `hashCode()`:
```java
@Override
public int hashCode() {
    return Objects.hash(someField);
}
```

### Важное замечание

Если вы переопределяете метод `equals()`, вы также должны переопределить метод `hashCode()`, чтобы удовлетворить контракт между этими двумя методами. Невыполнение этого требования может привести к непредсказуемому поведению в коллекциях, использующих хэш-коды.

Пример:
```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    MyClass myClass = (MyClass) obj;
    return this.someField.equals(myClass.someField);
}

@Override
public int hashCode() {
    return Objects.hash(someField);
}
```

Переопределяя методы таким образом, вы гарантируете корректную и предсказуемую работу ваших объектов в коллекциях, использующих хэширование.